C000                              ORG     $C000
                      
0076                  controlreg  EQU     $0076       ;zero page copy of control register 1
0077                  mempage     EQU     $0077       ;zero page copy of control register 2 (memory paging)
00E6                  MDREG       EQU     $00E6       ;zero page copy of MD register
FF24                  memreg1     EQU     $FF24       ;control register 1
FF25                  memreg2     EQU     $FF25       ;control register 2
FF00                  pia0base    EQU     $FF00       ;PIA registers
FF04                  pia1base    EQU     $FF04
FF08                  pia2base    EQU     $FF08
FF0C                  aciabase    EQU     $FF0C       ;ACIA registers
0100                  intpolltab  EQU     $0100       ;table of mapped registers to poll on interrupt 38 bytes max
                                                      ;terminates with a $0000 word
                      
                      * Verify operation of cpu
C000  10CE7FFF        rst_entry   LDS     #$7FFF      ;initialise system stack
C004  CE77FF                      LDU     #$77FF      ;initialise user stack
C007  8600                        LDA     #$00
C009  1F8B                        TFR     A,DP        ;set DP to 0
C00B  B70076                      STA     controlreg  ;initialise control register copy with 0
C00E  B7FF24                      STA     memreg1     ;set control register to 0
C011  B70077                      STA     mempage     ;set memory page copy to 0
C014  B7FF25                      STA     memreg2     ;set memory page to 0
C017  B70100                      STA     intpolltab  ;empty interrupt poll table
C01A  B70101                      STA     intpolltab+1
C01D  B700E6                      STA     MDREG       ;initialise copy of ME register
C020  8601                        LDA     #$01
C022  BDC0F9                      JSR     SETPMD
C025  BDC0D7                      JSR     unmaskint   ;enable interrupts
                                  
C028  C602            test        LDB     #$02
C02A  8655            teststart   LDA     #$55
C02C  8E6000                      LDX     #$6000
                      
C02F  A784            loop1       STA     $0000, X    ;fill $0000 to $5FFF
C031  301F                        LEAX    -1, X
C033  26FA                        BNE     loop1
C035  86AA                        LDA     #$AA
C037  8E6000                      LDX     #$6000
                      
C03A  A784            loop2       STA     $0000, X    ;fill $0000 to $5FFF
C03C  301F                        LEAX    -1, X
C03E  26FA                        BNE     loop2
C040  F70076                      STB     controlreg
C043  C802                        EORB    #$02
C045  20E3                        BRA     teststart   ;repeat
                      
                      * set paged memory page
                      * A = page number
C047  B7FF25          setpage     STA     memreg2     ;set memory page
C04A  B70077                      STA     mempage
C04D  39                          RTS
                      
                      * Control memory paging mode
                      * Depending on register A
                      * A = 0 32K ram, 32K rom
                      * A <> 0 32K ram, 16K page, 16k shadow rom
                      
                      * Assumes direct page location control reg 
                      * contains a copy of memreg1 and direct page
                      * location mempage contains a copy of memreg2
                      
                      * Assumes extended memory is available
C04E  8100            pagemode    CMPA    #$00        ;enable/disable paging
C050  260C                        BNE     enablepage
C052  86FE            disablepage LDA     #$FE
C054  B40076                      ANDA    controlreg
C057  B70076                      STA     controlreg
C05A  B7FF24                      STA     memreg1     ;disable
C05D  39                          RTS
C05E  3402            enablepage  PSHS    A           ;enable
C060  8601                        LDA     #$01
C062  BA0076                      ORA     controlreg
C065  B70076                      STA     controlreg
C068  B7FF24                      STA     memreg1
C06B  3582                        PULS    A,PC
                      
C06D  3436            shadow      PSHS    A,B,X,Y     ;shadow rom into high mem
                      * disable interrupts
C06F  BDC0D4                      JSR     maskint
                      * copy interrupt vectors first as precaution
C072  8EFFF0                      LDX     #$FFF0
C075  108E4000                    LDY     #$4000
C079  10860010                    LDW     #$0010
C07D  BDC0CF                      JSR     blockcopy
C080  8601                        LDA     #$01
C082  BDC04E                      JSR     pagemode
C085  8E4000                      LDX     #$4000
C088  108EFFF0                    LDY     #$FFF0
C08C  10860010                    LDW     #$0010
C090  BDC0CF                      JSR     blockcopy
C093  8600                        LDA     #$00
C095  BDC04E                      JSR     pagemode
                      * copy rom from C000 to 4000
C098  8EC000                      LDX     #$C000
C09B  108E4000                    LDY     #$4000
C09F  10863F00                    LDW     #$3F00
C0A3  BDC0CF                      JSR     blockcopy
                      * enable page mode
C0A6  8601                        LDA     #$01
C0A8  BDC04E                      JSR     pagemode
                      * copy rom from 4000 back to C000
C0AB  8E4000                      LDX     #$4000
C0AE  108EC000                    LDY     #$C000
C0B2  10863F00                    LDW     #$3F00
C0B6  BDC0CF                      JSR     blockcopy
                      * re-enable interrupts
C0B9  BDC0D7                      JSR     unmaskint
C0BC  35B6                        PULS    A,B,X,Y,PC
                      
                      * swap memory page
                      * A = page number
                      * tests if memory paging is enabled
                      * nb: this code must not be held
                      *     in paged memory to avoid
                      *     unexpected behaviour on return
C0BE  3404            pageswap    PSHS    B
C0C0  F60076                      LDB     controlreg
C0C3  C401                        ANDB    #$01
C0C5  2706                        BEQ     swapret
C0C7  B70077                      STA     mempage
C0CA  B7FF25                      STA     memreg2
C0CD  3584            swapret     PULS    B,PC
                      
                      * copy rom block from X to Y
                      * X = start address
                      * Y = destination address
                      * W = length
C0CF  113812          blockcopy   TFM     X+,Y+           ; 6309 specific implementation - will fail on a 6809
C0D2  3580                        PULS    PC
                      
                      * disable interrupts (ignores existing state)
C0D4  1A50            maskint     ORCC    #%01010000
C0D6  39                          RTS
                      
                      * enable interrupts (ignores prior state)
C0D7  1CAF            unmaskint   ANDCC   #%10101111
C0D9  39                          RTS
                      
                      * poll external interrupts
                      * check interrupt poll table
                      * each entry is 6 bytes:
                      *  byte 0/1 is the address to test
                      *  byte 2 is the test mask
                      *  byte 3 is control over positive or negative test
                      *  byte 4/5 is the jump address
                      * halts on first zero word entry at 0/1
                      * while flexible and extendable it is also slow
                      * rapid interrupts will becoming blocking
C0DA  10BE0100        pollint     LDY     intpolltab  ;point Y at start of table
C0DE  AEA1            pollloop    LDX     ,Y++        ;load first register address
C0E0  2601                        BNE     scanpoll    ;proceed if non-zero value found
C0E2  3B                          RTI                 ;release from poll without action
C0E3  A6A0            scanpoll    LDA     ,Y+         ;grab test mask
C0E5  E6A0                        LDB     ,Y+         ;grab test type
C0E7  2608                        BNE     pollpos     ;select positive of negative test
C0E9  A484            pollneg     ANDA    ,X          ;mask address at X
C0EB  270A                        BEQ     vectorpoll  ;if 0 result use vector
C0ED  3122            pollnext    LEAY    2,Y         ;on negative result skip vector
C0EF  20ED                        BRA     pollloop    ;next entry
C0F1  A484            pollpos     ANDA    ,X          ;mask address at X
C0F3  2602                        BNE     vectorpoll  ;if non0 result use vector
C0F5  20F6                        BRA     pollnext    ;next entry
C0F7  6EA4            vectorpoll  JMP     ,Y          ;vector to identified handler
                      
                      * Change processor to Emulation Mode or Native Mode,
                      * depending on value in Register A
                      * A=0 Emulation Mode
                      * A<>0 Native Mode
                      *
                      * Assumes direct page location MDREG contains an
                      * accurate image of the MD register contents (The
                      * program must initialize MDREG to $00 at start-up).
                      *
                      * Since LDMD accepts only an immediate operand, we
                      * push the appropriate LDMD / RTS sequence onto the
                      * stack and call it as a subroutine.
                      * Works for 6309 only.
C0F9  3417            SETPMD      PSHS    X,D,CC      ;Save registers
C0FB  1A50                        ORCC    #$50        ;Make operation indivisible
C0FD  F600E6                      LDB     MDREG       ;Get mode register image
C100  C4FE                        ANDB    #$FE        ; strip mode selection bit (Emulation)
C102  4D                          TSTA
C103  2702                        BEQ     SETMD2      ;Skip next part if want Emulation
C105  CA01                        ORB     #$01        ;Set Native mode bit (INCB lacks clarity)
C107  F700E6          SETMD2      STB     MDREG       ;B has right value - update register image
C10A  8639                        LDA     #$39        ;RTS op-code
C10C  1E98                        EXG     B,A         ;Now A = LDMD's immed. operand, B = RTS
C10E  8E103D                      LDX     #$103D      ;X has LDMD's 2-byte op-code
C111  1E01                        EXG     D,X         ;Now D:X = 10 3D <value> 39
C113  3416                        PSHS    X,D         ;Put subroutine on stack
C115  ADE4                        JSR     ,S          ;Call subroutine, setting mode
C117  3264                        LEAS    4,S         ; throw away subroutine when done.
C119  3597                        PULS    CC,D,X,PC   ; and return to caller.
                      
C11B  3B              nmi_entry   RTI
C11C  3B              swi_entry   RTI
C11D  7EC0DA          irq_entry   JMP     pollint
C120  3B              firq_entry  RTI
C121  3B              swi2_entry  RTI
C122  3B              swi3_entry  RTI
C123  3B              div0_entry  RTI
                      
                      * Boot and interrupt vectors
FFF0                              ORG     $FFF0
FFF0  C123            div0        FDB     div0_entry  ;specific to 6309 native mode
FFF2  C122            swi3        FDB     swi3_entry
FFF4  C121            swi2        FDB     swi2_entry
FFF6  C120            firq        FDB     firq_entry
FFF8  C11D            irq         FDB     irq_entry
FFFA  C11C            swi         FDB     swi_entry
FFFC  C11B            nmi         FDB     nmi_entry
FFFE  C000            reset       FDB     rst_entry
